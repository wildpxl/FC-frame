"use strict";
/* tslint:disable */
/* eslint-disable */
/**
 * Farcaster API V2
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 2.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.UserApi = exports.UserApiFactory = exports.UserApiFp = exports.UserApiAxiosParamCreator = void 0;
const axios_1 = __importDefault(require("axios"));
// Some imports not used depending on template conditions
// @ts-ignore
const common_1 = require("../common");
// @ts-ignore
const base_1 = require("../base");
/**
 * UserApi - axios parameter creator
 * @export
 */
const UserApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Removes verification for an eth address for the user \\ (In order to delete verification `signer_uuid` must be approved)
         * @summary Delete verification
         * @param {RemoveVerificationReqBody} remove_verification_req_body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<OperationResponse>} A promise that resolves to a `OperationResponse` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/delete-verification)
         *
         */
        deleteVerification: async (remove_verification_req_body, options = {}) => {
            // verify required parameter 'remove_verification_req_body' is not null or undefined
            (0, common_1.assertParamExists)('deleteVerification', 'remove_verification_req_body', remove_verification_req_body);
            const localVarPath = `/farcaster/user/verification`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(remove_verification_req_body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches information about multiple users based on FIDs
         * @summary By FIDs
         * @param {string} fids Comma separated list of FIDs, up to 100 at a time
         * @param {number} [viewer_fid]
         * @param {boolean} [x_neynar_experimental] Enables experimental features
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<BulkUsersResponse>} A promise that resolves to a `BulkUsersResponse` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-bulk-users)
         *
         */
        fetchBulkUsers: async (fids, viewer_fid, x_neynar_experimental, options = {}) => {
            // verify required parameter 'fids' is not null or undefined
            (0, common_1.assertParamExists)('fetchBulkUsers', 'fids', fids);
            const localVarPath = `/farcaster/user/bulk`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
            if (fids !== undefined) {
                localVarQueryParameter['fids'] = fids;
            }
            if (viewer_fid !== undefined) {
                localVarQueryParameter['viewer_fid'] = viewer_fid;
            }
            if (x_neynar_experimental != null) {
                localVarHeaderParameter['x-neynar-experimental'] = typeof x_neynar_experimental === 'string'
                    ? x_neynar_experimental
                    : JSON.stringify(x_neynar_experimental);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches all users based on multiple Ethereum or Solana addresses.  Each farcaster user has a custody Ethereum address and optionally verified Ethereum or Solana addresses. This endpoint returns all users that have any of the given addresses as their custody or verified Ethereum or Solana addresses.  A custody address can be associated with only 1 farcaster user at a time but a verified address can be associated with multiple users. You can pass in Ethereum and Solana addresses, comma separated, in the same request. The response will contain users associated with the given addresses.
         * @summary By Eth or Sol addresses
         * @param {string} addresses Comma separated list of Ethereum addresses, up to 350 at a time
         * @param {string} [address_types] Customize which address types the request should search for. This is a comma-separated string that can include the following values: \&#39;custody_address\&#39; and \&#39;verified_address\&#39;. By default api returns both. To select multiple types, use a comma-separated list of these values.
         * @param {number} [viewer_fid]
         * @param {boolean} [x_neynar_experimental] Enables experimental features
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<BulkUsersByAddressResponse>} A promise that resolves to a `BulkUsersByAddressResponse` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-bulk-users-by-ethereum-address)
         *
         */
        fetchBulkUsersByEthereumAddress: async (addresses, address_types, viewer_fid, x_neynar_experimental, options = {}) => {
            // verify required parameter 'addresses' is not null or undefined
            (0, common_1.assertParamExists)('fetchBulkUsersByEthereumAddress', 'addresses', addresses);
            const localVarPath = `/farcaster/user/bulk-by-address`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
            if (addresses !== undefined) {
                localVarQueryParameter['addresses'] = addresses;
            }
            if (address_types !== undefined) {
                localVarQueryParameter['address_types'] = address_types;
            }
            if (viewer_fid !== undefined) {
                localVarQueryParameter['viewer_fid'] = viewer_fid;
            }
            if (x_neynar_experimental != null) {
                localVarHeaderParameter['x-neynar-experimental'] = typeof x_neynar_experimental === 'string'
                    ? x_neynar_experimental
                    : JSON.stringify(x_neynar_experimental);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches power users based on Warpcast power badges. Information is updated once a day.
         * @summary Power users
         * @param {number} [viewer_fid]
         * @param {number} [limit] Number of power users to fetch  (Default: 25, Maximum: 100)
         * @param {string} [cursor] Pagination cursor.
         * @param {boolean} [x_neynar_experimental] Enables experimental features
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<UsersResponse>} A promise that resolves to a `UsersResponse` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-power-users)
         *
         */
        fetchPowerUsers: async (viewer_fid, limit, cursor, x_neynar_experimental, options = {}) => {
            const localVarPath = `/farcaster/user/power`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
            if (viewer_fid !== undefined) {
                localVarQueryParameter['viewer_fid'] = viewer_fid;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }
            if (x_neynar_experimental != null) {
                localVarHeaderParameter['x-neynar-experimental'] = typeof x_neynar_experimental === 'string'
                    ? x_neynar_experimental
                    : JSON.stringify(x_neynar_experimental);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches power users and respond in a backwards compatible format to Warpcast\'s deprecated power badge endpoint.
         * @summary Power user FIDs
         * @param {boolean} [x_neynar_experimental] Enables experimental features
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<UserPowerLiteResponse>} A promise that resolves to a `UserPowerLiteResponse` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-power-users-lite)
         *
         */
        fetchPowerUsersLite: async (x_neynar_experimental, options = {}) => {
            const localVarPath = `/farcaster/user/power_lite`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
            if (x_neynar_experimental != null) {
                localVarHeaderParameter['x-neynar-experimental'] = typeof x_neynar_experimental === 'string'
                    ? x_neynar_experimental
                    : JSON.stringify(x_neynar_experimental);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches the token balances of a user given their FID
         * @summary Token balance
         * @param {number} fid FID of the user to fetch
         * @param {Array<Networks>} networks Comma separated list of networks to fetch balances for. Currently, only \&quot;base\&quot; is supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<BalanceResponse>} A promise that resolves to a `BalanceResponse` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-user-balance)
         *
         */
        fetchUserBalance: async (fid, networks, options = {}) => {
            // verify required parameter 'fid' is not null or undefined
            (0, common_1.assertParamExists)('fetchUserBalance', 'fid', fid);
            // verify required parameter 'networks' is not null or undefined
            (0, common_1.assertParamExists)('fetchUserBalance', 'networks', networks);
            const localVarPath = `/farcaster/user/balance`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
            if (fid !== undefined) {
                localVarQueryParameter['fid'] = fid;
            }
            if (networks) {
                localVarQueryParameter['networks'] = networks.join(base_1.COLLECTION_FORMATS.csv);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches a list of users given a location
         * @summary By location
         * @param {number} latitude Latitude of the location
         * @param {number} longitude Longitude of the location
         * @param {number} [viewer_fid] FID of the user viewing the feed. Providing this will return a list of users that respects this user\&#39;s mutes and blocks and includes &#x60;viewer_context&#x60;.
         * @param {number} [limit] Number of results to fetch  (Default: 25, Maximum: 100)
         * @param {string} [cursor] Pagination cursor
         * @param {boolean} [x_neynar_experimental] Enables experimental features
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<UsersResponse>} A promise that resolves to a `UsersResponse` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-users-by-location)
         *
         */
        fetchUsersByLocation: async (latitude, longitude, viewer_fid, limit, cursor, x_neynar_experimental, options = {}) => {
            // verify required parameter 'latitude' is not null or undefined
            (0, common_1.assertParamExists)('fetchUsersByLocation', 'latitude', latitude);
            // verify required parameter 'longitude' is not null or undefined
            (0, common_1.assertParamExists)('fetchUsersByLocation', 'longitude', longitude);
            const localVarPath = `/farcaster/user/by_location`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
            if (latitude !== undefined) {
                localVarQueryParameter['latitude'] = latitude;
            }
            if (longitude !== undefined) {
                localVarQueryParameter['longitude'] = longitude;
            }
            if (viewer_fid !== undefined) {
                localVarQueryParameter['viewer_fid'] = viewer_fid;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }
            if (x_neynar_experimental != null) {
                localVarHeaderParameter['x-neynar-experimental'] = typeof x_neynar_experimental === 'string'
                    ? x_neynar_experimental
                    : JSON.stringify(x_neynar_experimental);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Follow a user \\ (In order to follow a user `signer_uuid` must be approved)
         * @summary Follow user
         * @param {FollowReqBody} follow_req_body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<BulkFollowResponse>} A promise that resolves to a `BulkFollowResponse` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/follow-user)
         *
         */
        followUser: async (follow_req_body, options = {}) => {
            // verify required parameter 'follow_req_body' is not null or undefined
            (0, common_1.assertParamExists)('followUser', 'follow_req_body', follow_req_body);
            const localVarPath = `/farcaster/user/follow`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(follow_req_body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches FID to [assign it to new user](https://docs.neynar.com/reference/register-account)
         * @summary Fetch fresh FID
         * @param {boolean} [x_neynar_experimental] Enables experimental features
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<UserFIDResponse>} A promise that resolves to a `UserFIDResponse` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/get-fresh-account-fid)
         *
         */
        getFreshAccountFID: async (x_neynar_experimental, options = {}) => {
            const localVarPath = `/farcaster/user/fid`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
            if (x_neynar_experimental != null) {
                localVarHeaderParameter['x-neynar-experimental'] = typeof x_neynar_experimental === 'string'
                    ? x_neynar_experimental
                    : JSON.stringify(x_neynar_experimental);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lookup a user by custody-address
         * @summary By custody-address
         * @param {string} custody_address Custody Address associated with mnemonic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<UserResponse>} A promise that resolves to a `UserResponse` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/lookup-user-by-custody-address)
         *
         */
        lookupUserByCustodyAddress: async (custody_address, options = {}) => {
            // verify required parameter 'custody_address' is not null or undefined
            (0, common_1.assertParamExists)('lookupUserByCustodyAddress', 'custody_address', custody_address);
            const localVarPath = `/farcaster/user/custody-address`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
            if (custody_address !== undefined) {
                localVarQueryParameter['custody_address'] = custody_address;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches a single hydrated user object given a username
         * @summary By username
         * @param {string} username Username of the user to fetch
         * @param {number} [viewer_fid]
         * @param {boolean} [x_neynar_experimental] Enables experimental features
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<UserResponse>} A promise that resolves to a `UserResponse` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/lookup-user-by-username)
         *
         */
        lookupUserByUsername: async (username, viewer_fid, x_neynar_experimental, options = {}) => {
            // verify required parameter 'username' is not null or undefined
            (0, common_1.assertParamExists)('lookupUserByUsername', 'username', username);
            const localVarPath = `/farcaster/user/by_username`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
            if (username !== undefined) {
                localVarQueryParameter['username'] = username;
            }
            if (viewer_fid !== undefined) {
                localVarQueryParameter['viewer_fid'] = viewer_fid;
            }
            if (x_neynar_experimental != null) {
                localVarHeaderParameter['x-neynar-experimental'] = typeof x_neynar_experimental === 'string'
                    ? x_neynar_experimental
                    : JSON.stringify(x_neynar_experimental);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds verification for an eth address or contract for the user \\ (In order to add verification `signer_uuid` must be approved)
         * @summary Add verification
         * @param {AddVerificationReqBody} add_verification_req_body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<OperationResponse>} A promise that resolves to a `OperationResponse` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/publish-verification)
         *
         */
        publishVerification: async (add_verification_req_body, options = {}) => {
            // verify required parameter 'add_verification_req_body' is not null or undefined
            (0, common_1.assertParamExists)('publishVerification', 'add_verification_req_body', add_verification_req_body);
            const localVarPath = `/farcaster/user/verification`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(add_verification_req_body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Register account on farcaster.  **Note:** This API must be called within 10 minutes of the fetch FID API call (i.e., /v2/farcaster/user/fid). Otherwise, Neynar will assign this FID to another available user.
         * @summary Register new account
         * @param {RegisterUserReqBody} register_user_req_body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<RegisterUserResponse>} A promise that resolves to a `RegisterUserResponse` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/register-account)
         *
         */
        registerAccount: async (register_user_req_body, options = {}) => {
            // verify required parameter 'register_user_req_body' is not null or undefined
            (0, common_1.assertParamExists)('registerAccount', 'register_user_req_body', register_user_req_body);
            const localVarPath = `/farcaster/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(register_user_req_body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search for Usernames
         * @summary Search for Usernames
         * @param {string} q
         * @param {number} [viewer_fid] Providing this will return search results that respects this user\&#39;s mutes and blocks and includes &#x60;viewer_context&#x60;.
         * @param {number} [limit] Number of users to fetch  (Default: 5, Maximum: 10)
         * @param {string} [cursor] Pagination cursor.
         * @param {boolean} [x_neynar_experimental] Enables experimental features
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<UserSearchResponse>} A promise that resolves to a `UserSearchResponse` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/search-user)
         *
         */
        searchUser: async (q, viewer_fid, limit, cursor, x_neynar_experimental, options = {}) => {
            // verify required parameter 'q' is not null or undefined
            (0, common_1.assertParamExists)('searchUser', 'q', q);
            const localVarPath = `/farcaster/user/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }
            if (viewer_fid !== undefined) {
                localVarQueryParameter['viewer_fid'] = viewer_fid;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }
            if (x_neynar_experimental != null) {
                localVarHeaderParameter['x-neynar-experimental'] = typeof x_neynar_experimental === 'string'
                    ? x_neynar_experimental
                    : JSON.stringify(x_neynar_experimental);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Unfollow a user \\ (In order to unfollow a user `signer_uuid` must be approved)
         * @summary Unfollow user
         * @param {FollowReqBody} follow_req_body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<BulkFollowResponse>} A promise that resolves to a `BulkFollowResponse` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/unfollow-user)
         *
         */
        unfollowUser: async (follow_req_body, options = {}) => {
            // verify required parameter 'follow_req_body' is not null or undefined
            (0, common_1.assertParamExists)('unfollowUser', 'follow_req_body', follow_req_body);
            const localVarPath = `/farcaster/user/follow`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(follow_req_body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update user profile \\ (In order to update user\'s profile `signer_uuid` must be approved)
         * @summary Update user profile
         * @param {UpdateUserReqBody} update_user_req_body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<OperationResponse>} A promise that resolves to a `OperationResponse` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/update-user)
         *
         */
        updateUser: async (update_user_req_body, options = {}) => {
            // verify required parameter 'update_user_req_body' is not null or undefined
            (0, common_1.assertParamExists)('updateUser', 'update_user_req_body', update_user_req_body);
            const localVarPath = `/farcaster/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(update_user_req_body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.UserApiAxiosParamCreator = UserApiAxiosParamCreator;
/**
 * UserApi - functional programming interface
 * @export
 */
const UserApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.UserApiAxiosParamCreator)(configuration);
    return {
        /**
         * Removes verification for an eth address for the user \\ (In order to delete verification `signer_uuid` must be approved)
         * @summary Delete verification
         * @param {RemoveVerificationReqBody} remove_verification_req_body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<OperationResponse>} A promise that resolves to a `OperationResponse` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/delete-verification)
         *
         */
        async deleteVerification(remove_verification_req_body, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteVerification(remove_verification_req_body, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['UserApi.deleteVerification']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Fetches information about multiple users based on FIDs
         * @summary By FIDs
         * @param {string} fids Comma separated list of FIDs, up to 100 at a time
         * @param {number} [viewer_fid]
         * @param {boolean} [x_neynar_experimental] Enables experimental features
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<BulkUsersResponse>} A promise that resolves to a `BulkUsersResponse` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-bulk-users)
         *
         */
        async fetchBulkUsers(fids, viewer_fid, x_neynar_experimental, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchBulkUsers(fids, viewer_fid, x_neynar_experimental, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['UserApi.fetchBulkUsers']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Fetches all users based on multiple Ethereum or Solana addresses.  Each farcaster user has a custody Ethereum address and optionally verified Ethereum or Solana addresses. This endpoint returns all users that have any of the given addresses as their custody or verified Ethereum or Solana addresses.  A custody address can be associated with only 1 farcaster user at a time but a verified address can be associated with multiple users. You can pass in Ethereum and Solana addresses, comma separated, in the same request. The response will contain users associated with the given addresses.
         * @summary By Eth or Sol addresses
         * @param {string} addresses Comma separated list of Ethereum addresses, up to 350 at a time
         * @param {string} [address_types] Customize which address types the request should search for. This is a comma-separated string that can include the following values: \&#39;custody_address\&#39; and \&#39;verified_address\&#39;. By default api returns both. To select multiple types, use a comma-separated list of these values.
         * @param {number} [viewer_fid]
         * @param {boolean} [x_neynar_experimental] Enables experimental features
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<BulkUsersByAddressResponse>} A promise that resolves to a `BulkUsersByAddressResponse` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-bulk-users-by-ethereum-address)
         *
         */
        async fetchBulkUsersByEthereumAddress(addresses, address_types, viewer_fid, x_neynar_experimental, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchBulkUsersByEthereumAddress(addresses, address_types, viewer_fid, x_neynar_experimental, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['UserApi.fetchBulkUsersByEthereumAddress']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Fetches power users based on Warpcast power badges. Information is updated once a day.
         * @summary Power users
         * @param {number} [viewer_fid]
         * @param {number} [limit] Number of power users to fetch  (Default: 25, Maximum: 100)
         * @param {string} [cursor] Pagination cursor.
         * @param {boolean} [x_neynar_experimental] Enables experimental features
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<UsersResponse>} A promise that resolves to a `UsersResponse` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-power-users)
         *
         */
        async fetchPowerUsers(viewer_fid, limit, cursor, x_neynar_experimental, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchPowerUsers(viewer_fid, limit, cursor, x_neynar_experimental, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['UserApi.fetchPowerUsers']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Fetches power users and respond in a backwards compatible format to Warpcast\'s deprecated power badge endpoint.
         * @summary Power user FIDs
         * @param {boolean} [x_neynar_experimental] Enables experimental features
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<UserPowerLiteResponse>} A promise that resolves to a `UserPowerLiteResponse` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-power-users-lite)
         *
         */
        async fetchPowerUsersLite(x_neynar_experimental, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchPowerUsersLite(x_neynar_experimental, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['UserApi.fetchPowerUsersLite']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Fetches the token balances of a user given their FID
         * @summary Token balance
         * @param {number} fid FID of the user to fetch
         * @param {Array<Networks>} networks Comma separated list of networks to fetch balances for. Currently, only \&quot;base\&quot; is supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<BalanceResponse>} A promise that resolves to a `BalanceResponse` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-user-balance)
         *
         */
        async fetchUserBalance(fid, networks, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchUserBalance(fid, networks, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['UserApi.fetchUserBalance']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Fetches a list of users given a location
         * @summary By location
         * @param {number} latitude Latitude of the location
         * @param {number} longitude Longitude of the location
         * @param {number} [viewer_fid] FID of the user viewing the feed. Providing this will return a list of users that respects this user\&#39;s mutes and blocks and includes &#x60;viewer_context&#x60;.
         * @param {number} [limit] Number of results to fetch  (Default: 25, Maximum: 100)
         * @param {string} [cursor] Pagination cursor
         * @param {boolean} [x_neynar_experimental] Enables experimental features
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<UsersResponse>} A promise that resolves to a `UsersResponse` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-users-by-location)
         *
         */
        async fetchUsersByLocation(latitude, longitude, viewer_fid, limit, cursor, x_neynar_experimental, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchUsersByLocation(latitude, longitude, viewer_fid, limit, cursor, x_neynar_experimental, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['UserApi.fetchUsersByLocation']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Follow a user \\ (In order to follow a user `signer_uuid` must be approved)
         * @summary Follow user
         * @param {FollowReqBody} follow_req_body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<BulkFollowResponse>} A promise that resolves to a `BulkFollowResponse` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/follow-user)
         *
         */
        async followUser(follow_req_body, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.followUser(follow_req_body, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['UserApi.followUser']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Fetches FID to [assign it to new user](https://docs.neynar.com/reference/register-account)
         * @summary Fetch fresh FID
         * @param {boolean} [x_neynar_experimental] Enables experimental features
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<UserFIDResponse>} A promise that resolves to a `UserFIDResponse` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/get-fresh-account-fid)
         *
         */
        async getFreshAccountFID(x_neynar_experimental, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFreshAccountFID(x_neynar_experimental, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['UserApi.getFreshAccountFID']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Lookup a user by custody-address
         * @summary By custody-address
         * @param {string} custody_address Custody Address associated with mnemonic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<UserResponse>} A promise that resolves to a `UserResponse` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/lookup-user-by-custody-address)
         *
         */
        async lookupUserByCustodyAddress(custody_address, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.lookupUserByCustodyAddress(custody_address, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['UserApi.lookupUserByCustodyAddress']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Fetches a single hydrated user object given a username
         * @summary By username
         * @param {string} username Username of the user to fetch
         * @param {number} [viewer_fid]
         * @param {boolean} [x_neynar_experimental] Enables experimental features
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<UserResponse>} A promise that resolves to a `UserResponse` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/lookup-user-by-username)
         *
         */
        async lookupUserByUsername(username, viewer_fid, x_neynar_experimental, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.lookupUserByUsername(username, viewer_fid, x_neynar_experimental, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['UserApi.lookupUserByUsername']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Adds verification for an eth address or contract for the user \\ (In order to add verification `signer_uuid` must be approved)
         * @summary Add verification
         * @param {AddVerificationReqBody} add_verification_req_body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<OperationResponse>} A promise that resolves to a `OperationResponse` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/publish-verification)
         *
         */
        async publishVerification(add_verification_req_body, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.publishVerification(add_verification_req_body, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['UserApi.publishVerification']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Register account on farcaster.  **Note:** This API must be called within 10 minutes of the fetch FID API call (i.e., /v2/farcaster/user/fid). Otherwise, Neynar will assign this FID to another available user.
         * @summary Register new account
         * @param {RegisterUserReqBody} register_user_req_body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<RegisterUserResponse>} A promise that resolves to a `RegisterUserResponse` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/register-account)
         *
         */
        async registerAccount(register_user_req_body, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.registerAccount(register_user_req_body, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['UserApi.registerAccount']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Search for Usernames
         * @summary Search for Usernames
         * @param {string} q
         * @param {number} [viewer_fid] Providing this will return search results that respects this user\&#39;s mutes and blocks and includes &#x60;viewer_context&#x60;.
         * @param {number} [limit] Number of users to fetch  (Default: 5, Maximum: 10)
         * @param {string} [cursor] Pagination cursor.
         * @param {boolean} [x_neynar_experimental] Enables experimental features
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<UserSearchResponse>} A promise that resolves to a `UserSearchResponse` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/search-user)
         *
         */
        async searchUser(q, viewer_fid, limit, cursor, x_neynar_experimental, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchUser(q, viewer_fid, limit, cursor, x_neynar_experimental, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['UserApi.searchUser']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Unfollow a user \\ (In order to unfollow a user `signer_uuid` must be approved)
         * @summary Unfollow user
         * @param {FollowReqBody} follow_req_body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<BulkFollowResponse>} A promise that resolves to a `BulkFollowResponse` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/unfollow-user)
         *
         */
        async unfollowUser(follow_req_body, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.unfollowUser(follow_req_body, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['UserApi.unfollowUser']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update user profile \\ (In order to update user\'s profile `signer_uuid` must be approved)
         * @summary Update user profile
         * @param {UpdateUserReqBody} update_user_req_body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<OperationResponse>} A promise that resolves to a `OperationResponse` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/update-user)
         *
         */
        async updateUser(update_user_req_body, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUser(update_user_req_body, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['UserApi.updateUser']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    };
};
exports.UserApiFp = UserApiFp;
/**
 * UserApi - factory interface
 * @export
 */
const UserApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.UserApiFp)(configuration);
    return {
        /**
         * Removes verification for an eth address for the user \\ (In order to delete verification `signer_uuid` must be approved)
         * @summary Delete verification
         * @param {UserApiDeleteVerificationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<OperationResponse>} A promise that resolves to a `OperationResponse` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/delete-verification)
         *
         */
        deleteVerification(requestParameters, options) {
            return localVarFp.deleteVerification(requestParameters.remove_verification_req_body, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetches information about multiple users based on FIDs
         * @summary By FIDs
         * @param {UserApiFetchBulkUsersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<BulkUsersResponse>} A promise that resolves to a `BulkUsersResponse` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-bulk-users)
         *
         */
        fetchBulkUsers(requestParameters, options) {
            return localVarFp.fetchBulkUsers(requestParameters.fids, requestParameters.viewer_fid, requestParameters.x_neynar_experimental, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetches all users based on multiple Ethereum or Solana addresses.  Each farcaster user has a custody Ethereum address and optionally verified Ethereum or Solana addresses. This endpoint returns all users that have any of the given addresses as their custody or verified Ethereum or Solana addresses.  A custody address can be associated with only 1 farcaster user at a time but a verified address can be associated with multiple users. You can pass in Ethereum and Solana addresses, comma separated, in the same request. The response will contain users associated with the given addresses.
         * @summary By Eth or Sol addresses
         * @param {UserApiFetchBulkUsersByEthereumAddressRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<BulkUsersByAddressResponse>} A promise that resolves to a `BulkUsersByAddressResponse` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-bulk-users-by-ethereum-address)
         *
         */
        fetchBulkUsersByEthereumAddress(requestParameters, options) {
            return localVarFp.fetchBulkUsersByEthereumAddress(requestParameters.addresses, requestParameters.address_types, requestParameters.viewer_fid, requestParameters.x_neynar_experimental, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetches power users based on Warpcast power badges. Information is updated once a day.
         * @summary Power users
         * @param {UserApiFetchPowerUsersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<UsersResponse>} A promise that resolves to a `UsersResponse` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-power-users)
         *
         */
        fetchPowerUsers(requestParameters = {}, options) {
            return localVarFp.fetchPowerUsers(requestParameters.viewer_fid, requestParameters.limit, requestParameters.cursor, requestParameters.x_neynar_experimental, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetches power users and respond in a backwards compatible format to Warpcast\'s deprecated power badge endpoint.
         * @summary Power user FIDs
         * @param {UserApiFetchPowerUsersLiteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<UserPowerLiteResponse>} A promise that resolves to a `UserPowerLiteResponse` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-power-users-lite)
         *
         */
        fetchPowerUsersLite(requestParameters = {}, options) {
            return localVarFp.fetchPowerUsersLite(requestParameters.x_neynar_experimental, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetches the token balances of a user given their FID
         * @summary Token balance
         * @param {UserApiFetchUserBalanceRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<BalanceResponse>} A promise that resolves to a `BalanceResponse` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-user-balance)
         *
         */
        fetchUserBalance(requestParameters, options) {
            return localVarFp.fetchUserBalance(requestParameters.fid, requestParameters.networks, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetches a list of users given a location
         * @summary By location
         * @param {UserApiFetchUsersByLocationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<UsersResponse>} A promise that resolves to a `UsersResponse` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-users-by-location)
         *
         */
        fetchUsersByLocation(requestParameters, options) {
            return localVarFp.fetchUsersByLocation(requestParameters.latitude, requestParameters.longitude, requestParameters.viewer_fid, requestParameters.limit, requestParameters.cursor, requestParameters.x_neynar_experimental, options).then((request) => request(axios, basePath));
        },
        /**
         * Follow a user \\ (In order to follow a user `signer_uuid` must be approved)
         * @summary Follow user
         * @param {UserApiFollowUserRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<BulkFollowResponse>} A promise that resolves to a `BulkFollowResponse` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/follow-user)
         *
         */
        followUser(requestParameters, options) {
            return localVarFp.followUser(requestParameters.follow_req_body, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetches FID to [assign it to new user](https://docs.neynar.com/reference/register-account)
         * @summary Fetch fresh FID
         * @param {UserApiGetFreshAccountFIDRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<UserFIDResponse>} A promise that resolves to a `UserFIDResponse` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/get-fresh-account-fid)
         *
         */
        getFreshAccountFID(requestParameters = {}, options) {
            return localVarFp.getFreshAccountFID(requestParameters.x_neynar_experimental, options).then((request) => request(axios, basePath));
        },
        /**
         * Lookup a user by custody-address
         * @summary By custody-address
         * @param {UserApiLookupUserByCustodyAddressRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<UserResponse>} A promise that resolves to a `UserResponse` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/lookup-user-by-custody-address)
         *
         */
        lookupUserByCustodyAddress(requestParameters, options) {
            return localVarFp.lookupUserByCustodyAddress(requestParameters.custody_address, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetches a single hydrated user object given a username
         * @summary By username
         * @param {UserApiLookupUserByUsernameRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<UserResponse>} A promise that resolves to a `UserResponse` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/lookup-user-by-username)
         *
         */
        lookupUserByUsername(requestParameters, options) {
            return localVarFp.lookupUserByUsername(requestParameters.username, requestParameters.viewer_fid, requestParameters.x_neynar_experimental, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds verification for an eth address or contract for the user \\ (In order to add verification `signer_uuid` must be approved)
         * @summary Add verification
         * @param {UserApiPublishVerificationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<OperationResponse>} A promise that resolves to a `OperationResponse` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/publish-verification)
         *
         */
        publishVerification(requestParameters, options) {
            return localVarFp.publishVerification(requestParameters.add_verification_req_body, options).then((request) => request(axios, basePath));
        },
        /**
         * Register account on farcaster.  **Note:** This API must be called within 10 minutes of the fetch FID API call (i.e., /v2/farcaster/user/fid). Otherwise, Neynar will assign this FID to another available user.
         * @summary Register new account
         * @param {UserApiRegisterAccountRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<RegisterUserResponse>} A promise that resolves to a `RegisterUserResponse` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/register-account)
         *
         */
        registerAccount(requestParameters, options) {
            return localVarFp.registerAccount(requestParameters.register_user_req_body, options).then((request) => request(axios, basePath));
        },
        /**
         * Search for Usernames
         * @summary Search for Usernames
         * @param {UserApiSearchUserRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<UserSearchResponse>} A promise that resolves to a `UserSearchResponse` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/search-user)
         *
         */
        searchUser(requestParameters, options) {
            return localVarFp.searchUser(requestParameters.q, requestParameters.viewer_fid, requestParameters.limit, requestParameters.cursor, requestParameters.x_neynar_experimental, options).then((request) => request(axios, basePath));
        },
        /**
         * Unfollow a user \\ (In order to unfollow a user `signer_uuid` must be approved)
         * @summary Unfollow user
         * @param {UserApiUnfollowUserRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<BulkFollowResponse>} A promise that resolves to a `BulkFollowResponse` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/unfollow-user)
         *
         */
        unfollowUser(requestParameters, options) {
            return localVarFp.unfollowUser(requestParameters.follow_req_body, options).then((request) => request(axios, basePath));
        },
        /**
         * Update user profile \\ (In order to update user\'s profile `signer_uuid` must be approved)
         * @summary Update user profile
         * @param {UserApiUpdateUserRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<OperationResponse>} A promise that resolves to a `OperationResponse` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/update-user)
         *
         */
        updateUser(requestParameters, options) {
            return localVarFp.updateUser(requestParameters.update_user_req_body, options).then((request) => request(axios, basePath));
        },
    };
};
exports.UserApiFactory = UserApiFactory;
/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
class UserApi extends base_1.BaseAPI {
    /**
     * Removes verification for an eth address for the user \\ (In order to delete verification `signer_uuid` must be approved)
     * @summary Delete verification
     * @param {UserApiDeleteVerificationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     * @returns {Promise<OperationResponse>} A promise that resolves to a `OperationResponse` object
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/delete-verification)
     *
     */
    deleteVerification(requestParameters, options) {
        return (0, exports.UserApiFp)(this.configuration).deleteVerification(requestParameters.remove_verification_req_body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetches information about multiple users based on FIDs
     * @summary By FIDs
     * @param {UserApiFetchBulkUsersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     * @returns {Promise<BulkUsersResponse>} A promise that resolves to a `BulkUsersResponse` object
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-bulk-users)
     *
     */
    fetchBulkUsers(requestParameters, options) {
        return (0, exports.UserApiFp)(this.configuration).fetchBulkUsers(requestParameters.fids, requestParameters.viewer_fid, requestParameters.x_neynar_experimental, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetches all users based on multiple Ethereum or Solana addresses.  Each farcaster user has a custody Ethereum address and optionally verified Ethereum or Solana addresses. This endpoint returns all users that have any of the given addresses as their custody or verified Ethereum or Solana addresses.  A custody address can be associated with only 1 farcaster user at a time but a verified address can be associated with multiple users. You can pass in Ethereum and Solana addresses, comma separated, in the same request. The response will contain users associated with the given addresses.
     * @summary By Eth or Sol addresses
     * @param {UserApiFetchBulkUsersByEthereumAddressRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     * @returns {Promise<BulkUsersByAddressResponse>} A promise that resolves to a `BulkUsersByAddressResponse` object
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-bulk-users-by-ethereum-address)
     *
     */
    fetchBulkUsersByEthereumAddress(requestParameters, options) {
        return (0, exports.UserApiFp)(this.configuration).fetchBulkUsersByEthereumAddress(requestParameters.addresses, requestParameters.address_types, requestParameters.viewer_fid, requestParameters.x_neynar_experimental, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetches power users based on Warpcast power badges. Information is updated once a day.
     * @summary Power users
     * @param {UserApiFetchPowerUsersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     * @returns {Promise<UsersResponse>} A promise that resolves to a `UsersResponse` object
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-power-users)
     *
     */
    fetchPowerUsers(requestParameters = {}, options) {
        return (0, exports.UserApiFp)(this.configuration).fetchPowerUsers(requestParameters.viewer_fid, requestParameters.limit, requestParameters.cursor, requestParameters.x_neynar_experimental, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetches power users and respond in a backwards compatible format to Warpcast\'s deprecated power badge endpoint.
     * @summary Power user FIDs
     * @param {UserApiFetchPowerUsersLiteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     * @returns {Promise<UserPowerLiteResponse>} A promise that resolves to a `UserPowerLiteResponse` object
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-power-users-lite)
     *
     */
    fetchPowerUsersLite(requestParameters = {}, options) {
        return (0, exports.UserApiFp)(this.configuration).fetchPowerUsersLite(requestParameters.x_neynar_experimental, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetches the token balances of a user given their FID
     * @summary Token balance
     * @param {UserApiFetchUserBalanceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     * @returns {Promise<BalanceResponse>} A promise that resolves to a `BalanceResponse` object
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-user-balance)
     *
     */
    fetchUserBalance(requestParameters, options) {
        return (0, exports.UserApiFp)(this.configuration).fetchUserBalance(requestParameters.fid, requestParameters.networks, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetches a list of users given a location
     * @summary By location
     * @param {UserApiFetchUsersByLocationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     * @returns {Promise<UsersResponse>} A promise that resolves to a `UsersResponse` object
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-users-by-location)
     *
     */
    fetchUsersByLocation(requestParameters, options) {
        return (0, exports.UserApiFp)(this.configuration).fetchUsersByLocation(requestParameters.latitude, requestParameters.longitude, requestParameters.viewer_fid, requestParameters.limit, requestParameters.cursor, requestParameters.x_neynar_experimental, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Follow a user \\ (In order to follow a user `signer_uuid` must be approved)
     * @summary Follow user
     * @param {UserApiFollowUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     * @returns {Promise<BulkFollowResponse>} A promise that resolves to a `BulkFollowResponse` object
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/follow-user)
     *
     */
    followUser(requestParameters, options) {
        return (0, exports.UserApiFp)(this.configuration).followUser(requestParameters.follow_req_body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetches FID to [assign it to new user](https://docs.neynar.com/reference/register-account)
     * @summary Fetch fresh FID
     * @param {UserApiGetFreshAccountFIDRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     * @returns {Promise<UserFIDResponse>} A promise that resolves to a `UserFIDResponse` object
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/get-fresh-account-fid)
     *
     */
    getFreshAccountFID(requestParameters = {}, options) {
        return (0, exports.UserApiFp)(this.configuration).getFreshAccountFID(requestParameters.x_neynar_experimental, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Lookup a user by custody-address
     * @summary By custody-address
     * @param {UserApiLookupUserByCustodyAddressRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     * @returns {Promise<UserResponse>} A promise that resolves to a `UserResponse` object
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/lookup-user-by-custody-address)
     *
     */
    lookupUserByCustodyAddress(requestParameters, options) {
        return (0, exports.UserApiFp)(this.configuration).lookupUserByCustodyAddress(requestParameters.custody_address, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetches a single hydrated user object given a username
     * @summary By username
     * @param {UserApiLookupUserByUsernameRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     * @returns {Promise<UserResponse>} A promise that resolves to a `UserResponse` object
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/lookup-user-by-username)
     *
     */
    lookupUserByUsername(requestParameters, options) {
        return (0, exports.UserApiFp)(this.configuration).lookupUserByUsername(requestParameters.username, requestParameters.viewer_fid, requestParameters.x_neynar_experimental, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Adds verification for an eth address or contract for the user \\ (In order to add verification `signer_uuid` must be approved)
     * @summary Add verification
     * @param {UserApiPublishVerificationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     * @returns {Promise<OperationResponse>} A promise that resolves to a `OperationResponse` object
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/publish-verification)
     *
     */
    publishVerification(requestParameters, options) {
        return (0, exports.UserApiFp)(this.configuration).publishVerification(requestParameters.add_verification_req_body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Register account on farcaster.  **Note:** This API must be called within 10 minutes of the fetch FID API call (i.e., /v2/farcaster/user/fid). Otherwise, Neynar will assign this FID to another available user.
     * @summary Register new account
     * @param {UserApiRegisterAccountRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     * @returns {Promise<RegisterUserResponse>} A promise that resolves to a `RegisterUserResponse` object
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/register-account)
     *
     */
    registerAccount(requestParameters, options) {
        return (0, exports.UserApiFp)(this.configuration).registerAccount(requestParameters.register_user_req_body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Search for Usernames
     * @summary Search for Usernames
     * @param {UserApiSearchUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     * @returns {Promise<UserSearchResponse>} A promise that resolves to a `UserSearchResponse` object
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/search-user)
     *
     */
    searchUser(requestParameters, options) {
        return (0, exports.UserApiFp)(this.configuration).searchUser(requestParameters.q, requestParameters.viewer_fid, requestParameters.limit, requestParameters.cursor, requestParameters.x_neynar_experimental, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Unfollow a user \\ (In order to unfollow a user `signer_uuid` must be approved)
     * @summary Unfollow user
     * @param {UserApiUnfollowUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     * @returns {Promise<BulkFollowResponse>} A promise that resolves to a `BulkFollowResponse` object
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/unfollow-user)
     *
     */
    unfollowUser(requestParameters, options) {
        return (0, exports.UserApiFp)(this.configuration).unfollowUser(requestParameters.follow_req_body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update user profile \\ (In order to update user\'s profile `signer_uuid` must be approved)
     * @summary Update user profile
     * @param {UserApiUpdateUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     * @returns {Promise<OperationResponse>} A promise that resolves to a `OperationResponse` object
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/update-user)
     *
     */
    updateUser(requestParameters, options) {
        return (0, exports.UserApiFp)(this.configuration).updateUser(requestParameters.update_user_req_body, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.UserApi = UserApi;
