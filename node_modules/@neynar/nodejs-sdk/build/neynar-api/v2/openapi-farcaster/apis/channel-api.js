"use strict";
/* tslint:disable */
/* eslint-disable */
/**
 * Farcaster API V2
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 2.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FetchTrendingChannelsTimeWindowEnum = exports.ChannelApi = exports.ChannelApiFactory = exports.ChannelApiFp = exports.ChannelApiAxiosParamCreator = void 0;
const axios_1 = __importDefault(require("axios"));
// Some imports not used depending on template conditions
// @ts-ignore
const common_1 = require("../common");
// @ts-ignore
const base_1 = require("../base");
/**
 * ChannelApi - axios parameter creator
 * @export
 */
const ChannelApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Returns a list of all channels with their details
         * @summary Fetch all channels with their details
         * @param {number} [limit] Number of results to fetch  (Default: 20, Maximum: 200)
         * @param {string} [cursor] Pagination cursor.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<ChannelListResponse>} A promise that resolves to a `ChannelListResponse` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-all-channels)
         *
         */
        fetchAllChannels: async (limit, cursor, options = {}) => {
            const localVarPath = `/farcaster/channel/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns details of multiple channels
         * @summary Bulk fetch
         * @param {string} ids Comma separated list of channel IDs or parent_urls, up to 100 at a time
         * @param {ChannelType} [type] Type of identifier being used to query the channels. Defaults to ID.
         * @param {number} [viewer_fid] FID of the user viewing the channels.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<ChannelResponseBulk>} A promise that resolves to a `ChannelResponseBulk` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-bulk-channels)
         *
         */
        fetchBulkChannels: async (ids, type, viewer_fid, options = {}) => {
            // verify required parameter 'ids' is not null or undefined
            (0, common_1.assertParamExists)('fetchBulkChannels', 'ids', ids);
            const localVarPath = `/farcaster/channel/bulk`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }
            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }
            if (viewer_fid !== undefined) {
                localVarQueryParameter['viewer_fid'] = viewer_fid;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch a list of invites, either in a channel or for a user. If both are provided, open channel invite for that user is returned.
         * @summary Open invites
         * @param {string} [channel_id] Channel ID for the channel being queried
         * @param {number} [invited_fid] FID of the user being invited
         * @param {number} [limit] Number of results to fetch  (Default: 20, Maximum: 100)
         * @param {string} [cursor] Pagination cursor.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<ChannelMemberInviteListResponse>} A promise that resolves to a `ChannelMemberInviteListResponse` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-channel-invites)
         *
         */
        fetchChannelInvites: async (channel_id, invited_fid, limit, cursor, options = {}) => {
            const localVarPath = `/farcaster/channel/member/invite/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
            if (channel_id !== undefined) {
                localVarQueryParameter['channel_id'] = channel_id;
            }
            if (invited_fid !== undefined) {
                localVarQueryParameter['invited_fid'] = invited_fid;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch a list of members in a channel
         * @summary Fetch members
         * @param {string} channel_id Channel ID for the channel being queried
         * @param {number} [fid] FID of the user being queried. Specify this to check if a user is a member of the channel without paginating through all members.
         * @param {number} [limit] Number of results to fetch  (Default: 20, Maximum: 100)
         * @param {string} [cursor] Pagination cursor.
         * @param {boolean} [x_neynar_experimental] Enables experimental features
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<ChannelMemberListResponse>} A promise that resolves to a `ChannelMemberListResponse` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-channel-members)
         *
         */
        fetchChannelMembers: async (channel_id, fid, limit, cursor, x_neynar_experimental, options = {}) => {
            // verify required parameter 'channel_id' is not null or undefined
            (0, common_1.assertParamExists)('fetchChannelMembers', 'channel_id', channel_id);
            const localVarPath = `/farcaster/channel/member/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
            if (channel_id !== undefined) {
                localVarQueryParameter['channel_id'] = channel_id;
            }
            if (fid !== undefined) {
                localVarQueryParameter['fid'] = fid;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }
            if (x_neynar_experimental != null) {
                localVarHeaderParameter['x-neynar-experimental'] = typeof x_neynar_experimental === 'string'
                    ? x_neynar_experimental
                    : JSON.stringify(x_neynar_experimental);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of followers for a specific channel. Max limit is 1000. Use cursor for pagination.
         * @summary For channel
         * @param {string} id Channel ID for the channel being queried
         * @param {number} [viewer_fid] Providing this will return a list of followers that respects this user\&#39;s mutes and blocks and includes &#x60;viewer_context&#x60;.
         * @param {string} [cursor] Pagination cursor.
         * @param {number} [limit] Number of followers to fetch  (Default: 25, Maximum: 1000)
         * @param {boolean} [x_neynar_experimental] Enables experimental features
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<UsersResponse>} A promise that resolves to a `UsersResponse` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-followers-for-a-channel)
         *
         */
        fetchFollowersForAChannel: async (id, viewer_fid, cursor, limit, x_neynar_experimental, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('fetchFollowersForAChannel', 'id', id);
            const localVarPath = `/farcaster/channel/followers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }
            if (viewer_fid !== undefined) {
                localVarQueryParameter['viewer_fid'] = viewer_fid;
            }
            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (x_neynar_experimental != null) {
                localVarHeaderParameter['x-neynar-experimental'] = typeof x_neynar_experimental === 'string'
                    ? x_neynar_experimental
                    : JSON.stringify(x_neynar_experimental);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of relevant channel followers for a specific FID. This usually shows on a channel as \"X, Y, Z follow this channel\".
         * @summary Relevant followers
         * @param {string} id Channel ID being queried
         * @param {number} viewer_fid The FID of the user to customize this response for. Providing this will also return a list of followers that respects this user\&#39;s mutes and blocks and includes &#x60;viewer_context&#x60;.
         * @param {boolean} [x_neynar_experimental] Enables experimental features
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<RelevantFollowersResponse>} A promise that resolves to a `RelevantFollowersResponse` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-relevant-followers-for-a-channel)
         *
         */
        fetchRelevantFollowersForAChannel: async (id, viewer_fid, x_neynar_experimental, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('fetchRelevantFollowersForAChannel', 'id', id);
            // verify required parameter 'viewer_fid' is not null or undefined
            (0, common_1.assertParamExists)('fetchRelevantFollowersForAChannel', 'viewer_fid', viewer_fid);
            const localVarPath = `/farcaster/channel/followers/relevant`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }
            if (viewer_fid !== undefined) {
                localVarQueryParameter['viewer_fid'] = viewer_fid;
            }
            if (x_neynar_experimental != null) {
                localVarHeaderParameter['x-neynar-experimental'] = typeof x_neynar_experimental === 'string'
                    ? x_neynar_experimental
                    : JSON.stringify(x_neynar_experimental);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of trending channels based on activity
         * @summary Channels by activity
         * @param {FetchTrendingChannelsTimeWindowEnum} [time_window]
         * @param {number} [limit] Number of results to fetch  (Default: 10, Maximum: 25)
         * @param {string} [cursor] Pagination cursor.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<TrendingChannelResponse>} A promise that resolves to a `TrendingChannelResponse` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-trending-channels)
         *
         */
        fetchTrendingChannels: async (time_window, limit, cursor, options = {}) => {
            const localVarPath = `/farcaster/channel/trending`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
            if (time_window !== undefined) {
                localVarQueryParameter['time_window'] = time_window;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of all channels with their details that an FID is a member of. Data may have a delay of up to 1 hour.
         * @summary Member of
         * @param {number} fid The FID of the user.
         * @param {number} [limit] Number of results to fetch  (Default: 20, Maximum: 100)
         * @param {string} [cursor] Pagination cursor.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<ChannelMemberListResponse>} A promise that resolves to a `ChannelMemberListResponse` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-user-channel-memberships)
         *
         */
        fetchUserChannelMemberships: async (fid, limit, cursor, options = {}) => {
            // verify required parameter 'fid' is not null or undefined
            (0, common_1.assertParamExists)('fetchUserChannelMemberships', 'fid', fid);
            const localVarPath = `/farcaster/user/memberships/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
            if (fid !== undefined) {
                localVarQueryParameter['fid'] = fid;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of all channels with their details that a FID follows.
         * @summary Following
         * @param {number} fid The FID of the user.
         * @param {number} [limit] Number of results to fetch  (Default: 25, Maximum: 100)
         * @param {string} [cursor] Pagination cursor.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<ChannelListResponse>} A promise that resolves to a `ChannelListResponse` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-user-channels)
         *
         */
        fetchUserChannels: async (fid, limit, cursor, options = {}) => {
            // verify required parameter 'fid' is not null or undefined
            (0, common_1.assertParamExists)('fetchUserChannels', 'fid', fid);
            const localVarPath = `/farcaster/user/channels`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
            if (fid !== undefined) {
                localVarQueryParameter['fid'] = fid;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches all channels that a user has casted in, in reverse chronological order.
         * @summary Fetch channels that user is active in
         * @param {number} fid The user\&#39;s FID (identifier)
         * @param {number} [limit] Number of results to fetch  (Default: 20, Maximum: 100)
         * @param {string} [cursor] Pagination cursor.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<UsersActiveChannelsResponse>} A promise that resolves to a `UsersActiveChannelsResponse` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-users-active-channels)
         *
         */
        fetchUsersActiveChannels: async (fid, limit, cursor, options = {}) => {
            // verify required parameter 'fid' is not null or undefined
            (0, common_1.assertParamExists)('fetchUsersActiveChannels', 'fid', fid);
            const localVarPath = `/farcaster/channel/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
            if (fid !== undefined) {
                localVarQueryParameter['fid'] = fid;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Follow a channel
         * @summary Follow a channel
         * @param {ChannelFollowReqBody} channel_follow_req_body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<OperationResponse>} A promise that resolves to a `OperationResponse` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/follow-channel)
         *
         */
        followChannel: async (channel_follow_req_body, options = {}) => {
            // verify required parameter 'channel_follow_req_body' is not null or undefined
            (0, common_1.assertParamExists)('followChannel', 'channel_follow_req_body', channel_follow_req_body);
            const localVarPath = `/farcaster/channel/follow`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(channel_follow_req_body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Invite a user to a channel
         * @summary Invite
         * @param {InviteChannelMemberReqBody} invite_channel_member_req_body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<OperationResponse>} A promise that resolves to a `OperationResponse` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/invite-channel-member)
         *
         */
        inviteChannelMember: async (invite_channel_member_req_body, options = {}) => {
            // verify required parameter 'invite_channel_member_req_body' is not null or undefined
            (0, common_1.assertParamExists)('inviteChannelMember', 'invite_channel_member_req_body', invite_channel_member_req_body);
            const localVarPath = `/farcaster/channel/member/invite`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(invite_channel_member_req_body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns details of a channel
         * @summary By ID or parent_url
         * @param {string} id Channel ID for the channel being queried
         * @param {ChannelType} [type] Type of identifier being used to query the channel. Defaults to ID.
         * @param {number} [viewer_fid] FID of the user viewing the channel.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<ChannelResponse>} A promise that resolves to a `ChannelResponse` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/lookup-channel)
         *
         */
        lookupChannel: async (id, type, viewer_fid, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('lookupChannel', 'id', id);
            const localVarPath = `/farcaster/channel`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }
            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }
            if (viewer_fid !== undefined) {
                localVarQueryParameter['viewer_fid'] = viewer_fid;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove a user from a channel or a user\'s invite to a channel role
         * @summary Remove user
         * @param {RemoveChannelMemberReqBody} remove_channel_member_req_body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<OperationResponse>} A promise that resolves to a `OperationResponse` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/remove-channel-member)
         *
         */
        removeChannelMember: async (remove_channel_member_req_body, options = {}) => {
            // verify required parameter 'remove_channel_member_req_body' is not null or undefined
            (0, common_1.assertParamExists)('removeChannelMember', 'remove_channel_member_req_body', remove_channel_member_req_body);
            const localVarPath = `/farcaster/channel/member`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(remove_channel_member_req_body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Accept or reject a channel invite
         * @summary Accept or reject an invite
         * @param {RespondChannelInviteReqBody} respond_channel_invite_req_body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<OperationResponse>} A promise that resolves to a `OperationResponse` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/respond-channel-invite)
         *
         */
        respondChannelInvite: async (respond_channel_invite_req_body, options = {}) => {
            // verify required parameter 'respond_channel_invite_req_body' is not null or undefined
            (0, common_1.assertParamExists)('respondChannelInvite', 'respond_channel_invite_req_body', respond_channel_invite_req_body);
            const localVarPath = `/farcaster/channel/member/invite`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(respond_channel_invite_req_body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of channels based on ID or name
         * @summary Search by ID or name
         * @param {string} q Channel ID or name for the channel being queried
         * @param {number} [limit] Number of results to fetch  (Default: 20, Maximum: 200)
         * @param {string} [cursor] Pagination cursor.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<ChannelSearchResponse>} A promise that resolves to a `ChannelSearchResponse` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/search-channels)
         *
         */
        searchChannels: async (q, limit, cursor, options = {}) => {
            // verify required parameter 'q' is not null or undefined
            (0, common_1.assertParamExists)('searchChannels', 'q', q);
            const localVarPath = `/farcaster/channel/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Unfollow a channel
         * @summary Unfollow a channel
         * @param {ChannelFollowReqBody} channel_follow_req_body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<OperationResponse>} A promise that resolves to a `OperationResponse` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/unfollow-channel)
         *
         */
        unfollowChannel: async (channel_follow_req_body, options = {}) => {
            // verify required parameter 'channel_follow_req_body' is not null or undefined
            (0, common_1.assertParamExists)('unfollowChannel', 'channel_follow_req_body', channel_follow_req_body);
            const localVarPath = `/farcaster/channel/follow`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(channel_follow_req_body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.ChannelApiAxiosParamCreator = ChannelApiAxiosParamCreator;
/**
 * ChannelApi - functional programming interface
 * @export
 */
const ChannelApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.ChannelApiAxiosParamCreator)(configuration);
    return {
        /**
         * Returns a list of all channels with their details
         * @summary Fetch all channels with their details
         * @param {number} [limit] Number of results to fetch  (Default: 20, Maximum: 200)
         * @param {string} [cursor] Pagination cursor.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<ChannelListResponse>} A promise that resolves to a `ChannelListResponse` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-all-channels)
         *
         */
        async fetchAllChannels(limit, cursor, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchAllChannels(limit, cursor, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ChannelApi.fetchAllChannels']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns details of multiple channels
         * @summary Bulk fetch
         * @param {string} ids Comma separated list of channel IDs or parent_urls, up to 100 at a time
         * @param {ChannelType} [type] Type of identifier being used to query the channels. Defaults to ID.
         * @param {number} [viewer_fid] FID of the user viewing the channels.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<ChannelResponseBulk>} A promise that resolves to a `ChannelResponseBulk` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-bulk-channels)
         *
         */
        async fetchBulkChannels(ids, type, viewer_fid, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchBulkChannels(ids, type, viewer_fid, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ChannelApi.fetchBulkChannels']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Fetch a list of invites, either in a channel or for a user. If both are provided, open channel invite for that user is returned.
         * @summary Open invites
         * @param {string} [channel_id] Channel ID for the channel being queried
         * @param {number} [invited_fid] FID of the user being invited
         * @param {number} [limit] Number of results to fetch  (Default: 20, Maximum: 100)
         * @param {string} [cursor] Pagination cursor.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<ChannelMemberInviteListResponse>} A promise that resolves to a `ChannelMemberInviteListResponse` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-channel-invites)
         *
         */
        async fetchChannelInvites(channel_id, invited_fid, limit, cursor, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchChannelInvites(channel_id, invited_fid, limit, cursor, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ChannelApi.fetchChannelInvites']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Fetch a list of members in a channel
         * @summary Fetch members
         * @param {string} channel_id Channel ID for the channel being queried
         * @param {number} [fid] FID of the user being queried. Specify this to check if a user is a member of the channel without paginating through all members.
         * @param {number} [limit] Number of results to fetch  (Default: 20, Maximum: 100)
         * @param {string} [cursor] Pagination cursor.
         * @param {boolean} [x_neynar_experimental] Enables experimental features
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<ChannelMemberListResponse>} A promise that resolves to a `ChannelMemberListResponse` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-channel-members)
         *
         */
        async fetchChannelMembers(channel_id, fid, limit, cursor, x_neynar_experimental, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchChannelMembers(channel_id, fid, limit, cursor, x_neynar_experimental, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ChannelApi.fetchChannelMembers']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list of followers for a specific channel. Max limit is 1000. Use cursor for pagination.
         * @summary For channel
         * @param {string} id Channel ID for the channel being queried
         * @param {number} [viewer_fid] Providing this will return a list of followers that respects this user\&#39;s mutes and blocks and includes &#x60;viewer_context&#x60;.
         * @param {string} [cursor] Pagination cursor.
         * @param {number} [limit] Number of followers to fetch  (Default: 25, Maximum: 1000)
         * @param {boolean} [x_neynar_experimental] Enables experimental features
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<UsersResponse>} A promise that resolves to a `UsersResponse` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-followers-for-a-channel)
         *
         */
        async fetchFollowersForAChannel(id, viewer_fid, cursor, limit, x_neynar_experimental, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchFollowersForAChannel(id, viewer_fid, cursor, limit, x_neynar_experimental, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ChannelApi.fetchFollowersForAChannel']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list of relevant channel followers for a specific FID. This usually shows on a channel as \"X, Y, Z follow this channel\".
         * @summary Relevant followers
         * @param {string} id Channel ID being queried
         * @param {number} viewer_fid The FID of the user to customize this response for. Providing this will also return a list of followers that respects this user\&#39;s mutes and blocks and includes &#x60;viewer_context&#x60;.
         * @param {boolean} [x_neynar_experimental] Enables experimental features
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<RelevantFollowersResponse>} A promise that resolves to a `RelevantFollowersResponse` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-relevant-followers-for-a-channel)
         *
         */
        async fetchRelevantFollowersForAChannel(id, viewer_fid, x_neynar_experimental, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchRelevantFollowersForAChannel(id, viewer_fid, x_neynar_experimental, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ChannelApi.fetchRelevantFollowersForAChannel']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list of trending channels based on activity
         * @summary Channels by activity
         * @param {FetchTrendingChannelsTimeWindowEnum} [time_window]
         * @param {number} [limit] Number of results to fetch  (Default: 10, Maximum: 25)
         * @param {string} [cursor] Pagination cursor.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<TrendingChannelResponse>} A promise that resolves to a `TrendingChannelResponse` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-trending-channels)
         *
         */
        async fetchTrendingChannels(time_window, limit, cursor, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchTrendingChannels(time_window, limit, cursor, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ChannelApi.fetchTrendingChannels']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list of all channels with their details that an FID is a member of. Data may have a delay of up to 1 hour.
         * @summary Member of
         * @param {number} fid The FID of the user.
         * @param {number} [limit] Number of results to fetch  (Default: 20, Maximum: 100)
         * @param {string} [cursor] Pagination cursor.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<ChannelMemberListResponse>} A promise that resolves to a `ChannelMemberListResponse` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-user-channel-memberships)
         *
         */
        async fetchUserChannelMemberships(fid, limit, cursor, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchUserChannelMemberships(fid, limit, cursor, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ChannelApi.fetchUserChannelMemberships']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list of all channels with their details that a FID follows.
         * @summary Following
         * @param {number} fid The FID of the user.
         * @param {number} [limit] Number of results to fetch  (Default: 25, Maximum: 100)
         * @param {string} [cursor] Pagination cursor.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<ChannelListResponse>} A promise that resolves to a `ChannelListResponse` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-user-channels)
         *
         */
        async fetchUserChannels(fid, limit, cursor, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchUserChannels(fid, limit, cursor, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ChannelApi.fetchUserChannels']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Fetches all channels that a user has casted in, in reverse chronological order.
         * @summary Fetch channels that user is active in
         * @param {number} fid The user\&#39;s FID (identifier)
         * @param {number} [limit] Number of results to fetch  (Default: 20, Maximum: 100)
         * @param {string} [cursor] Pagination cursor.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<UsersActiveChannelsResponse>} A promise that resolves to a `UsersActiveChannelsResponse` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-users-active-channels)
         *
         */
        async fetchUsersActiveChannels(fid, limit, cursor, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchUsersActiveChannels(fid, limit, cursor, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ChannelApi.fetchUsersActiveChannels']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Follow a channel
         * @summary Follow a channel
         * @param {ChannelFollowReqBody} channel_follow_req_body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<OperationResponse>} A promise that resolves to a `OperationResponse` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/follow-channel)
         *
         */
        async followChannel(channel_follow_req_body, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.followChannel(channel_follow_req_body, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ChannelApi.followChannel']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Invite a user to a channel
         * @summary Invite
         * @param {InviteChannelMemberReqBody} invite_channel_member_req_body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<OperationResponse>} A promise that resolves to a `OperationResponse` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/invite-channel-member)
         *
         */
        async inviteChannelMember(invite_channel_member_req_body, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.inviteChannelMember(invite_channel_member_req_body, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ChannelApi.inviteChannelMember']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns details of a channel
         * @summary By ID or parent_url
         * @param {string} id Channel ID for the channel being queried
         * @param {ChannelType} [type] Type of identifier being used to query the channel. Defaults to ID.
         * @param {number} [viewer_fid] FID of the user viewing the channel.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<ChannelResponse>} A promise that resolves to a `ChannelResponse` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/lookup-channel)
         *
         */
        async lookupChannel(id, type, viewer_fid, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.lookupChannel(id, type, viewer_fid, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ChannelApi.lookupChannel']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Remove a user from a channel or a user\'s invite to a channel role
         * @summary Remove user
         * @param {RemoveChannelMemberReqBody} remove_channel_member_req_body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<OperationResponse>} A promise that resolves to a `OperationResponse` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/remove-channel-member)
         *
         */
        async removeChannelMember(remove_channel_member_req_body, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeChannelMember(remove_channel_member_req_body, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ChannelApi.removeChannelMember']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Accept or reject a channel invite
         * @summary Accept or reject an invite
         * @param {RespondChannelInviteReqBody} respond_channel_invite_req_body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<OperationResponse>} A promise that resolves to a `OperationResponse` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/respond-channel-invite)
         *
         */
        async respondChannelInvite(respond_channel_invite_req_body, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.respondChannelInvite(respond_channel_invite_req_body, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ChannelApi.respondChannelInvite']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list of channels based on ID or name
         * @summary Search by ID or name
         * @param {string} q Channel ID or name for the channel being queried
         * @param {number} [limit] Number of results to fetch  (Default: 20, Maximum: 200)
         * @param {string} [cursor] Pagination cursor.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<ChannelSearchResponse>} A promise that resolves to a `ChannelSearchResponse` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/search-channels)
         *
         */
        async searchChannels(q, limit, cursor, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchChannels(q, limit, cursor, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ChannelApi.searchChannels']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Unfollow a channel
         * @summary Unfollow a channel
         * @param {ChannelFollowReqBody} channel_follow_req_body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<OperationResponse>} A promise that resolves to a `OperationResponse` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/unfollow-channel)
         *
         */
        async unfollowChannel(channel_follow_req_body, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.unfollowChannel(channel_follow_req_body, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ChannelApi.unfollowChannel']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    };
};
exports.ChannelApiFp = ChannelApiFp;
/**
 * ChannelApi - factory interface
 * @export
 */
const ChannelApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.ChannelApiFp)(configuration);
    return {
        /**
         * Returns a list of all channels with their details
         * @summary Fetch all channels with their details
         * @param {ChannelApiFetchAllChannelsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<ChannelListResponse>} A promise that resolves to a `ChannelListResponse` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-all-channels)
         *
         */
        fetchAllChannels(requestParameters = {}, options) {
            return localVarFp.fetchAllChannels(requestParameters.limit, requestParameters.cursor, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns details of multiple channels
         * @summary Bulk fetch
         * @param {ChannelApiFetchBulkChannelsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<ChannelResponseBulk>} A promise that resolves to a `ChannelResponseBulk` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-bulk-channels)
         *
         */
        fetchBulkChannels(requestParameters, options) {
            return localVarFp.fetchBulkChannels(requestParameters.ids, requestParameters.type, requestParameters.viewer_fid, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch a list of invites, either in a channel or for a user. If both are provided, open channel invite for that user is returned.
         * @summary Open invites
         * @param {ChannelApiFetchChannelInvitesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<ChannelMemberInviteListResponse>} A promise that resolves to a `ChannelMemberInviteListResponse` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-channel-invites)
         *
         */
        fetchChannelInvites(requestParameters = {}, options) {
            return localVarFp.fetchChannelInvites(requestParameters.channel_id, requestParameters.invited_fid, requestParameters.limit, requestParameters.cursor, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch a list of members in a channel
         * @summary Fetch members
         * @param {ChannelApiFetchChannelMembersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<ChannelMemberListResponse>} A promise that resolves to a `ChannelMemberListResponse` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-channel-members)
         *
         */
        fetchChannelMembers(requestParameters, options) {
            return localVarFp.fetchChannelMembers(requestParameters.channel_id, requestParameters.fid, requestParameters.limit, requestParameters.cursor, requestParameters.x_neynar_experimental, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of followers for a specific channel. Max limit is 1000. Use cursor for pagination.
         * @summary For channel
         * @param {ChannelApiFetchFollowersForAChannelRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<UsersResponse>} A promise that resolves to a `UsersResponse` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-followers-for-a-channel)
         *
         */
        fetchFollowersForAChannel(requestParameters, options) {
            return localVarFp.fetchFollowersForAChannel(requestParameters.id, requestParameters.viewer_fid, requestParameters.cursor, requestParameters.limit, requestParameters.x_neynar_experimental, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of relevant channel followers for a specific FID. This usually shows on a channel as \"X, Y, Z follow this channel\".
         * @summary Relevant followers
         * @param {ChannelApiFetchRelevantFollowersForAChannelRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<RelevantFollowersResponse>} A promise that resolves to a `RelevantFollowersResponse` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-relevant-followers-for-a-channel)
         *
         */
        fetchRelevantFollowersForAChannel(requestParameters, options) {
            return localVarFp.fetchRelevantFollowersForAChannel(requestParameters.id, requestParameters.viewer_fid, requestParameters.x_neynar_experimental, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of trending channels based on activity
         * @summary Channels by activity
         * @param {ChannelApiFetchTrendingChannelsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<TrendingChannelResponse>} A promise that resolves to a `TrendingChannelResponse` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-trending-channels)
         *
         */
        fetchTrendingChannels(requestParameters = {}, options) {
            return localVarFp.fetchTrendingChannels(requestParameters.time_window, requestParameters.limit, requestParameters.cursor, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of all channels with their details that an FID is a member of. Data may have a delay of up to 1 hour.
         * @summary Member of
         * @param {ChannelApiFetchUserChannelMembershipsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<ChannelMemberListResponse>} A promise that resolves to a `ChannelMemberListResponse` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-user-channel-memberships)
         *
         */
        fetchUserChannelMemberships(requestParameters, options) {
            return localVarFp.fetchUserChannelMemberships(requestParameters.fid, requestParameters.limit, requestParameters.cursor, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of all channels with their details that a FID follows.
         * @summary Following
         * @param {ChannelApiFetchUserChannelsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<ChannelListResponse>} A promise that resolves to a `ChannelListResponse` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-user-channels)
         *
         */
        fetchUserChannels(requestParameters, options) {
            return localVarFp.fetchUserChannels(requestParameters.fid, requestParameters.limit, requestParameters.cursor, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetches all channels that a user has casted in, in reverse chronological order.
         * @summary Fetch channels that user is active in
         * @param {ChannelApiFetchUsersActiveChannelsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<UsersActiveChannelsResponse>} A promise that resolves to a `UsersActiveChannelsResponse` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-users-active-channels)
         *
         */
        fetchUsersActiveChannels(requestParameters, options) {
            return localVarFp.fetchUsersActiveChannels(requestParameters.fid, requestParameters.limit, requestParameters.cursor, options).then((request) => request(axios, basePath));
        },
        /**
         * Follow a channel
         * @summary Follow a channel
         * @param {ChannelApiFollowChannelRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<OperationResponse>} A promise that resolves to a `OperationResponse` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/follow-channel)
         *
         */
        followChannel(requestParameters, options) {
            return localVarFp.followChannel(requestParameters.channel_follow_req_body, options).then((request) => request(axios, basePath));
        },
        /**
         * Invite a user to a channel
         * @summary Invite
         * @param {ChannelApiInviteChannelMemberRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<OperationResponse>} A promise that resolves to a `OperationResponse` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/invite-channel-member)
         *
         */
        inviteChannelMember(requestParameters, options) {
            return localVarFp.inviteChannelMember(requestParameters.invite_channel_member_req_body, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns details of a channel
         * @summary By ID or parent_url
         * @param {ChannelApiLookupChannelRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<ChannelResponse>} A promise that resolves to a `ChannelResponse` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/lookup-channel)
         *
         */
        lookupChannel(requestParameters, options) {
            return localVarFp.lookupChannel(requestParameters.id, requestParameters.type, requestParameters.viewer_fid, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove a user from a channel or a user\'s invite to a channel role
         * @summary Remove user
         * @param {ChannelApiRemoveChannelMemberRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<OperationResponse>} A promise that resolves to a `OperationResponse` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/remove-channel-member)
         *
         */
        removeChannelMember(requestParameters, options) {
            return localVarFp.removeChannelMember(requestParameters.remove_channel_member_req_body, options).then((request) => request(axios, basePath));
        },
        /**
         * Accept or reject a channel invite
         * @summary Accept or reject an invite
         * @param {ChannelApiRespondChannelInviteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<OperationResponse>} A promise that resolves to a `OperationResponse` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/respond-channel-invite)
         *
         */
        respondChannelInvite(requestParameters, options) {
            return localVarFp.respondChannelInvite(requestParameters.respond_channel_invite_req_body, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of channels based on ID or name
         * @summary Search by ID or name
         * @param {ChannelApiSearchChannelsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<ChannelSearchResponse>} A promise that resolves to a `ChannelSearchResponse` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/search-channels)
         *
         */
        searchChannels(requestParameters, options) {
            return localVarFp.searchChannels(requestParameters.q, requestParameters.limit, requestParameters.cursor, options).then((request) => request(axios, basePath));
        },
        /**
         * Unfollow a channel
         * @summary Unfollow a channel
         * @param {ChannelApiUnfollowChannelRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<OperationResponse>} A promise that resolves to a `OperationResponse` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/unfollow-channel)
         *
         */
        unfollowChannel(requestParameters, options) {
            return localVarFp.unfollowChannel(requestParameters.channel_follow_req_body, options).then((request) => request(axios, basePath));
        },
    };
};
exports.ChannelApiFactory = ChannelApiFactory;
/**
 * ChannelApi - object-oriented interface
 * @export
 * @class ChannelApi
 * @extends {BaseAPI}
 */
class ChannelApi extends base_1.BaseAPI {
    /**
     * Returns a list of all channels with their details
     * @summary Fetch all channels with their details
     * @param {ChannelApiFetchAllChannelsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     * @returns {Promise<ChannelListResponse>} A promise that resolves to a `ChannelListResponse` object
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-all-channels)
     *
     */
    fetchAllChannels(requestParameters = {}, options) {
        return (0, exports.ChannelApiFp)(this.configuration).fetchAllChannels(requestParameters.limit, requestParameters.cursor, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns details of multiple channels
     * @summary Bulk fetch
     * @param {ChannelApiFetchBulkChannelsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     * @returns {Promise<ChannelResponseBulk>} A promise that resolves to a `ChannelResponseBulk` object
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-bulk-channels)
     *
     */
    fetchBulkChannels(requestParameters, options) {
        return (0, exports.ChannelApiFp)(this.configuration).fetchBulkChannels(requestParameters.ids, requestParameters.type, requestParameters.viewer_fid, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetch a list of invites, either in a channel or for a user. If both are provided, open channel invite for that user is returned.
     * @summary Open invites
     * @param {ChannelApiFetchChannelInvitesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     * @returns {Promise<ChannelMemberInviteListResponse>} A promise that resolves to a `ChannelMemberInviteListResponse` object
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-channel-invites)
     *
     */
    fetchChannelInvites(requestParameters = {}, options) {
        return (0, exports.ChannelApiFp)(this.configuration).fetchChannelInvites(requestParameters.channel_id, requestParameters.invited_fid, requestParameters.limit, requestParameters.cursor, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetch a list of members in a channel
     * @summary Fetch members
     * @param {ChannelApiFetchChannelMembersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     * @returns {Promise<ChannelMemberListResponse>} A promise that resolves to a `ChannelMemberListResponse` object
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-channel-members)
     *
     */
    fetchChannelMembers(requestParameters, options) {
        return (0, exports.ChannelApiFp)(this.configuration).fetchChannelMembers(requestParameters.channel_id, requestParameters.fid, requestParameters.limit, requestParameters.cursor, requestParameters.x_neynar_experimental, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns a list of followers for a specific channel. Max limit is 1000. Use cursor for pagination.
     * @summary For channel
     * @param {ChannelApiFetchFollowersForAChannelRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     * @returns {Promise<UsersResponse>} A promise that resolves to a `UsersResponse` object
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-followers-for-a-channel)
     *
     */
    fetchFollowersForAChannel(requestParameters, options) {
        return (0, exports.ChannelApiFp)(this.configuration).fetchFollowersForAChannel(requestParameters.id, requestParameters.viewer_fid, requestParameters.cursor, requestParameters.limit, requestParameters.x_neynar_experimental, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns a list of relevant channel followers for a specific FID. This usually shows on a channel as \"X, Y, Z follow this channel\".
     * @summary Relevant followers
     * @param {ChannelApiFetchRelevantFollowersForAChannelRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     * @returns {Promise<RelevantFollowersResponse>} A promise that resolves to a `RelevantFollowersResponse` object
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-relevant-followers-for-a-channel)
     *
     */
    fetchRelevantFollowersForAChannel(requestParameters, options) {
        return (0, exports.ChannelApiFp)(this.configuration).fetchRelevantFollowersForAChannel(requestParameters.id, requestParameters.viewer_fid, requestParameters.x_neynar_experimental, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns a list of trending channels based on activity
     * @summary Channels by activity
     * @param {ChannelApiFetchTrendingChannelsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     * @returns {Promise<TrendingChannelResponse>} A promise that resolves to a `TrendingChannelResponse` object
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-trending-channels)
     *
     */
    fetchTrendingChannels(requestParameters = {}, options) {
        return (0, exports.ChannelApiFp)(this.configuration).fetchTrendingChannels(requestParameters.time_window, requestParameters.limit, requestParameters.cursor, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns a list of all channels with their details that an FID is a member of. Data may have a delay of up to 1 hour.
     * @summary Member of
     * @param {ChannelApiFetchUserChannelMembershipsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     * @returns {Promise<ChannelMemberListResponse>} A promise that resolves to a `ChannelMemberListResponse` object
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-user-channel-memberships)
     *
     */
    fetchUserChannelMemberships(requestParameters, options) {
        return (0, exports.ChannelApiFp)(this.configuration).fetchUserChannelMemberships(requestParameters.fid, requestParameters.limit, requestParameters.cursor, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns a list of all channels with their details that a FID follows.
     * @summary Following
     * @param {ChannelApiFetchUserChannelsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     * @returns {Promise<ChannelListResponse>} A promise that resolves to a `ChannelListResponse` object
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-user-channels)
     *
     */
    fetchUserChannels(requestParameters, options) {
        return (0, exports.ChannelApiFp)(this.configuration).fetchUserChannels(requestParameters.fid, requestParameters.limit, requestParameters.cursor, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetches all channels that a user has casted in, in reverse chronological order.
     * @summary Fetch channels that user is active in
     * @param {ChannelApiFetchUsersActiveChannelsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     * @returns {Promise<UsersActiveChannelsResponse>} A promise that resolves to a `UsersActiveChannelsResponse` object
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-users-active-channels)
     *
     */
    fetchUsersActiveChannels(requestParameters, options) {
        return (0, exports.ChannelApiFp)(this.configuration).fetchUsersActiveChannels(requestParameters.fid, requestParameters.limit, requestParameters.cursor, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Follow a channel
     * @summary Follow a channel
     * @param {ChannelApiFollowChannelRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     * @returns {Promise<OperationResponse>} A promise that resolves to a `OperationResponse` object
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/follow-channel)
     *
     */
    followChannel(requestParameters, options) {
        return (0, exports.ChannelApiFp)(this.configuration).followChannel(requestParameters.channel_follow_req_body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Invite a user to a channel
     * @summary Invite
     * @param {ChannelApiInviteChannelMemberRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     * @returns {Promise<OperationResponse>} A promise that resolves to a `OperationResponse` object
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/invite-channel-member)
     *
     */
    inviteChannelMember(requestParameters, options) {
        return (0, exports.ChannelApiFp)(this.configuration).inviteChannelMember(requestParameters.invite_channel_member_req_body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns details of a channel
     * @summary By ID or parent_url
     * @param {ChannelApiLookupChannelRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     * @returns {Promise<ChannelResponse>} A promise that resolves to a `ChannelResponse` object
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/lookup-channel)
     *
     */
    lookupChannel(requestParameters, options) {
        return (0, exports.ChannelApiFp)(this.configuration).lookupChannel(requestParameters.id, requestParameters.type, requestParameters.viewer_fid, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Remove a user from a channel or a user\'s invite to a channel role
     * @summary Remove user
     * @param {ChannelApiRemoveChannelMemberRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     * @returns {Promise<OperationResponse>} A promise that resolves to a `OperationResponse` object
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/remove-channel-member)
     *
     */
    removeChannelMember(requestParameters, options) {
        return (0, exports.ChannelApiFp)(this.configuration).removeChannelMember(requestParameters.remove_channel_member_req_body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Accept or reject a channel invite
     * @summary Accept or reject an invite
     * @param {ChannelApiRespondChannelInviteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     * @returns {Promise<OperationResponse>} A promise that resolves to a `OperationResponse` object
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/respond-channel-invite)
     *
     */
    respondChannelInvite(requestParameters, options) {
        return (0, exports.ChannelApiFp)(this.configuration).respondChannelInvite(requestParameters.respond_channel_invite_req_body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns a list of channels based on ID or name
     * @summary Search by ID or name
     * @param {ChannelApiSearchChannelsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     * @returns {Promise<ChannelSearchResponse>} A promise that resolves to a `ChannelSearchResponse` object
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/search-channels)
     *
     */
    searchChannels(requestParameters, options) {
        return (0, exports.ChannelApiFp)(this.configuration).searchChannels(requestParameters.q, requestParameters.limit, requestParameters.cursor, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Unfollow a channel
     * @summary Unfollow a channel
     * @param {ChannelApiUnfollowChannelRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     * @returns {Promise<OperationResponse>} A promise that resolves to a `OperationResponse` object
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/unfollow-channel)
     *
     */
    unfollowChannel(requestParameters, options) {
        return (0, exports.ChannelApiFp)(this.configuration).unfollowChannel(requestParameters.channel_follow_req_body, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.ChannelApi = ChannelApi;
/**
 * @export
 */
exports.FetchTrendingChannelsTimeWindowEnum = {
    _1d: '1d',
    _7d: '7d',
    _30d: '30d'
};
