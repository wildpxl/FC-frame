/// <reference types="node" />
import * as bundlesSrc from "./src/index.js";
import * as stream from "./src/stream/index.js";
declare const expObj: {
    stream: typeof stream;
    Signer: typeof bundlesSrc.Signer;
    indexToType: bundlesSrc.IndexToType;
    Curve25519: typeof bundlesSrc.Curve25519;
    Rsa4096: typeof bundlesSrc.Rsa4096;
    secp256k1: typeof bundlesSrc.secp256k1;
    ArweaveSigner: typeof bundlesSrc.ArweaveSigner;
    InjectedSolanaSigner: typeof bundlesSrc.InjectedSolanaSigner;
    SolanaSigner: typeof bundlesSrc.SolanaSigner;
    PolygonSigner: typeof bundlesSrc.PolygonSigner;
    NearSigner: typeof bundlesSrc.NearSigner;
    EthereumSigner: typeof bundlesSrc.EthereumSigner;
    AlgorandSigner: typeof bundlesSrc.AlgorandSigner;
    HexInjectedSolanaSigner: typeof bundlesSrc.HexInjectedSolanaSigner;
    HexSolanaSigner: typeof bundlesSrc.HexSolanaSigner;
    AptosSigner: typeof bundlesSrc.AptosSigner;
    InjectedAptosSigner: typeof bundlesSrc.InjectedAptosSigner;
    MultiSignatureAptosSigner: typeof bundlesSrc.MultiSignatureAptosSigner;
    TypedEthereumSigner: typeof bundlesSrc.TypedEthereumSigner;
    ArconnectSigner: typeof bundlesSrc.ArconnectSigner;
    InjectedEthereumSigner: typeof bundlesSrc.InjectedEthereumSigner;
    InjectedTypedEthereumSigner: typeof bundlesSrc.InjectedTypedEthereumSigner;
    keccak256(value: any): any;
    exportForTesting: {
        intToBuffer: (i: number) => Buffer;
        intToHex: (i: number) => string;
        isHexPrefixed: (value: any) => boolean;
        stripHexPrefix: (value: any) => any;
        padToEven: (value: any) => any;
        isHexString: (value: any, length?: number | undefined) => boolean;
        toBuffer: (value: any) => any;
    };
    unbundleData(txData: Buffer): bundlesSrc.Bundle;
    bundleAndSignData(dataItems: bundlesSrc.DataItem[], signer: bundlesSrc.Signer): Promise<bundlesSrc.Bundle>;
    getSignatureAndId(item: bundlesSrc.DataItem, signer: bundlesSrc.Signer): Promise<{
        signature: Buffer;
        id: Buffer;
    }>;
    sign(item: bundlesSrc.DataItem, signer: bundlesSrc.Signer): Promise<Buffer>;
    createData(data: string | Uint8Array, signer: bundlesSrc.Signer, opts?: bundlesSrc.DataItemCreateOptions | undefined): bundlesSrc.DataItem;
    Bundle: typeof bundlesSrc.Bundle;
    BundleItem: typeof bundlesSrc.BundleItem;
    SignatureConfig: typeof bundlesSrc.SignatureConfig;
    SIG_CONFIG: Record<bundlesSrc.SignatureConfig, bundlesSrc.SignatureMeta>;
    MIN_BINARY_SIZE: 80;
    MAX_TAG_BYTES: 4096;
    DataItem: typeof bundlesSrc.DataItem;
    serializeTags(tags: bundlesSrc.Tag[]): Buffer;
    deserializeTags(tagsBuffer: Buffer): bundlesSrc.Tag[];
    AVSCTap: typeof bundlesSrc.AVSCTap;
    longToNByteArray(N: number, long: number): Uint8Array;
    longTo8ByteArray(long: number): Uint8Array;
    shortTo2ByteArray(short: number): Uint8Array;
    longTo16ByteArray(long: number): Uint8Array;
    longTo32ByteArray(long: number): Uint8Array;
    byteArrayToLong(byteArray: Uint8Array): number;
    getCryptoDriver(): bundlesSrc.CryptoDriver;
    stringToBuffer: typeof bundlesSrc.stringToBuffer;
    concatBuffers: typeof bundlesSrc.concatBuffers;
    Transaction: typeof bundlesSrc.Transaction;
    deepHash: typeof bundlesSrc.deepHash;
    Arweave: typeof bundlesSrc.Arweave;
    CryptoDriver: typeof bundlesSrc.CryptoDriver;
};
export * from "./src/index.js";
export * from "./src/stream/index.js";
export default expObj;
export declare const bundles: {
    stream: typeof stream;
    Signer: typeof bundlesSrc.Signer;
    indexToType: bundlesSrc.IndexToType;
    Curve25519: typeof bundlesSrc.Curve25519;
    Rsa4096: typeof bundlesSrc.Rsa4096;
    secp256k1: typeof bundlesSrc.secp256k1;
    ArweaveSigner: typeof bundlesSrc.ArweaveSigner;
    InjectedSolanaSigner: typeof bundlesSrc.InjectedSolanaSigner;
    SolanaSigner: typeof bundlesSrc.SolanaSigner;
    PolygonSigner: typeof bundlesSrc.PolygonSigner;
    NearSigner: typeof bundlesSrc.NearSigner;
    EthereumSigner: typeof bundlesSrc.EthereumSigner;
    AlgorandSigner: typeof bundlesSrc.AlgorandSigner;
    HexInjectedSolanaSigner: typeof bundlesSrc.HexInjectedSolanaSigner;
    HexSolanaSigner: typeof bundlesSrc.HexSolanaSigner;
    AptosSigner: typeof bundlesSrc.AptosSigner;
    InjectedAptosSigner: typeof bundlesSrc.InjectedAptosSigner;
    MultiSignatureAptosSigner: typeof bundlesSrc.MultiSignatureAptosSigner;
    TypedEthereumSigner: typeof bundlesSrc.TypedEthereumSigner;
    ArconnectSigner: typeof bundlesSrc.ArconnectSigner;
    InjectedEthereumSigner: typeof bundlesSrc.InjectedEthereumSigner;
    InjectedTypedEthereumSigner: typeof bundlesSrc.InjectedTypedEthereumSigner;
    keccak256(value: any): any;
    exportForTesting: {
        intToBuffer: (i: number) => Buffer;
        intToHex: (i: number) => string;
        isHexPrefixed: (value: any) => boolean;
        stripHexPrefix: (value: any) => any;
        padToEven: (value: any) => any;
        isHexString: (value: any, length?: number | undefined) => boolean;
        toBuffer: (value: any) => any;
    };
    unbundleData(txData: Buffer): bundlesSrc.Bundle;
    bundleAndSignData(dataItems: bundlesSrc.DataItem[], signer: bundlesSrc.Signer): Promise<bundlesSrc.Bundle>;
    getSignatureAndId(item: bundlesSrc.DataItem, signer: bundlesSrc.Signer): Promise<{
        signature: Buffer;
        id: Buffer;
    }>;
    sign(item: bundlesSrc.DataItem, signer: bundlesSrc.Signer): Promise<Buffer>;
    createData(data: string | Uint8Array, signer: bundlesSrc.Signer, opts?: bundlesSrc.DataItemCreateOptions | undefined): bundlesSrc.DataItem;
    Bundle: typeof bundlesSrc.Bundle;
    BundleItem: typeof bundlesSrc.BundleItem;
    SignatureConfig: typeof bundlesSrc.SignatureConfig;
    SIG_CONFIG: Record<bundlesSrc.SignatureConfig, bundlesSrc.SignatureMeta>;
    MIN_BINARY_SIZE: 80;
    MAX_TAG_BYTES: 4096;
    DataItem: typeof bundlesSrc.DataItem;
    serializeTags(tags: bundlesSrc.Tag[]): Buffer;
    deserializeTags(tagsBuffer: Buffer): bundlesSrc.Tag[];
    AVSCTap: typeof bundlesSrc.AVSCTap;
    longToNByteArray(N: number, long: number): Uint8Array;
    longTo8ByteArray(long: number): Uint8Array;
    shortTo2ByteArray(short: number): Uint8Array;
    longTo16ByteArray(long: number): Uint8Array;
    longTo32ByteArray(long: number): Uint8Array;
    byteArrayToLong(byteArray: Uint8Array): number;
    getCryptoDriver(): bundlesSrc.CryptoDriver;
    stringToBuffer: typeof bundlesSrc.stringToBuffer;
    concatBuffers: typeof bundlesSrc.concatBuffers;
    Transaction: typeof bundlesSrc.Transaction;
    deepHash: typeof bundlesSrc.deepHash;
    Arweave: typeof bundlesSrc.Arweave;
    CryptoDriver: typeof bundlesSrc.CryptoDriver;
};
