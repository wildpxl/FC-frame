"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const bignumber_1 = require("@ethersproject/bignumber");
const providers_1 = require("@ethersproject/providers");
const wallet_1 = require("@ethersproject/wallet");
const bignumber_js_1 = tslib_1.__importDefault(require("bignumber.js"));
const bundles_1 = require("@irys/bundles");
const base_1 = require("@irys/upload/tokens/base");
const ethereumSigner = bundles_1.EthereumSigner;
class BaseEthereumToken extends base_1.BaseNodeToken {
    constructor(config) {
        super(config);
        this.base = ["wei", 1e18];
    }
    async getProvider() {
        if (!this.providerInstance) {
            this.providerInstance = new providers_1.JsonRpcProvider({
                url: this.providerUrl,
                skipFetchSetup: true,
                ...this?.opts?.providerOptions,
            });
            await this.providerInstance.ready;
        }
        return this.providerInstance;
    }
    async getTx(txId) {
        const provider = await this.getProvider();
        const response = await provider.getTransaction(txId);
        if (!response)
            throw new Error(`Unable to fetch Tx ${txId}`);
        if (!response.to)
            throw new Error(`Unable to determine transaction ${txId} recipient`);
        return {
            from: response.from,
            to: response.to,
            blockHeight: response.blockNumber ? new bignumber_js_1.default(response.blockNumber) : undefined,
            amount: new bignumber_js_1.default(response.value.toHexString(), 16),
            pending: response.blockNumber ? false : true,
            confirmed: response.confirmations >= this.minConfirm,
        };
    }
    ownerToAddress(owner) {
        return "0x" + (0, bundles_1.keccak256)(owner.slice(1)).slice(-20).toString("hex");
    }
    async sign(data) {
        const signer = this.getSigner();
        return signer.sign(data);
    }
    getSigner() {
        return new ethereumSigner(this.wallet);
    }
    verify(pub, data, signature) {
        return ethereumSigner.verify(pub, data, signature);
    }
    async getCurrentHeight() {
        const response = await (await this.getProvider()).send("eth_blockNumber", []);
        return new bignumber_js_1.default(response, 16);
    }
    async getFee(amount, to) {
        const provider = await this.getProvider();
        const _amount = new bignumber_js_1.default(amount);
        const tx = {
            from: this.address,
            to,
            value: "0x" + _amount.toString(16),
        };
        const estimatedGas = await provider.estimateGas(tx);
        const gasPrice = await provider.getGasPrice();
        // const b = await provider.send("eth_maxPriorityFeePerGas", [])
        // console.log(b)
        return new bignumber_js_1.default(estimatedGas.mul(gasPrice).toString());
    }
    async sendTx(data) {
        return await (await this.getProvider()).sendTransaction(data).catch((e) => {
            console.error(`Error occurred while sending a tx - ${e}`);
            throw e;
        });
    }
    async createTx(amount, to, fee) {
        const provider = await this.getProvider();
        const wallet = new wallet_1.Wallet(this.wallet, provider);
        const _amount = "0x" + new bignumber_js_1.default(amount).toString(16);
        let gasPrice = await provider.getGasPrice();
        const gasEstimate = fee ? bignumber_1.BigNumber.from(new bignumber_js_1.default(fee).dividedToIntegerBy(gasPrice.toString()).toFixed()) : undefined;
        // const estimatedGas = await provider.estimateGas({ from: this.address, to, value: _amount });
        // console.log({ gasPrice, estimatedGas })
        // if (fee) {
        //     gasPrice = ethers.BigNumber.from(Math.ceil(+fee / estimatedGas.toNumber()))
        // }
        if (this.name === "matic") {
            gasPrice = bignumber_1.BigNumber.from(new bignumber_js_1.default(gasPrice.toString()).multipliedBy(10).decimalPlaces(0).toString());
        }
        const tx = await wallet.populateTransaction({
            to,
            value: _amount,
            from: this.address,
            gasPrice,
            // gasLimit: estimatedGas,
            gasLimit: gasEstimate,
            // nonce: b // await provider.getTransactionCount(this.address),
            // chainId: await (await provider.getNetwork()).chainId
        });
        // tx.gasLimit = ethers.BigNumber.from(+(tx.gasLimit.toString()) * 4)
        const signedTx = await wallet.signTransaction(tx);
        const txId = "0x" + (0, bundles_1.keccak256)(Buffer.from(signedTx.slice(2), "hex")).toString("hex");
        // const c = await provider.call(tx);
        // console.log(c)
        return { txId, tx: signedTx };
    }
    getPublicKey() {
        return this.getSigner().publicKey;
    }
}
exports.default = BaseEthereumToken;
//# sourceMappingURL=ethereum.js.map