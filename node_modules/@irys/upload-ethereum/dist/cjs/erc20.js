"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.erc20abi = exports.BaseERC20Token = void 0;
const tslib_1 = require("tslib");
const bignumber_js_1 = tslib_1.__importDefault(require("bignumber.js"));
const contracts_1 = require("@ethersproject/contracts");
const wallet_1 = require("@ethersproject/wallet");
const bundles_1 = require("@irys/bundles");
const base_1 = require("@irys/upload/tokens/base");
const ethereum_1 = tslib_1.__importDefault(require("./ethereum"));
class BaseERC20Token extends ethereum_1.default {
    constructor(config) {
        super(config);
        this.contractAddress = config.contractAddress;
    }
    async getContract() {
        if (!this.contractInstance) {
            this.contractInstance = new contracts_1.Contract(this.contractAddress, exports.erc20abi, new wallet_1.Wallet(this.wallet, await this.getProvider()));
            this.base = ["wei", Math.pow(10, await this.contractInstance.decimals())];
        }
        return this.contractInstance;
    }
    async getTx(txId) {
        const response = await (await super.getProvider()).getTransaction(txId);
        if (!response)
            throw new Error("Tx doesn't exist");
        if (response.data.length !== 138 ||
            response.data.slice(2, 10) !== "a9059cbb" // standard ERC20-ABI method ID for transfers
        ) {
            throw new Error("Tx isn't a ERC20 transfer");
        }
        const to = `0x${response.data.slice(34, 74)}`;
        const amount = new bignumber_js_1.default(response.data.slice(74), 16);
        return {
            from: response.from,
            to,
            blockHeight: response.blockNumber ? new bignumber_js_1.default(response.blockNumber) : undefined,
            amount,
            pending: response.blockNumber ? false : true,
            confirmed: response.confirmations >= this.minConfirm,
        };
    }
    async getFee(amount, to) {
        const _amount = "0x" + new bignumber_js_1.default(amount).toString(16);
        const contract = await this.getContract();
        const provider = await this.getProvider();
        const gasPrice = await provider.getGasPrice();
        const gasLimit = await contract.estimateGas.transfer(to, _amount);
        const units = new bignumber_js_1.default(gasPrice.mul(gasLimit).toString()); // price in WEI
        return units;
        // below is cost in contract token units for the gas price
        // const [fiatGasPrice] = await this.getGas(); // get price of gas units
        // const value = fiatGasPrice.multipliedBy(units); // value of the fee
        // // convert value
        // const ctPrice = new BigNumber(await this.price()); // price for this token
        // const ctAmount = new BigNumber(value).dividedToIntegerBy(ctPrice);
        // // const b = ctAmount.multipliedBy(ctPrice)
        // // const c = value.dividedBy(this.base[1])
        // // console.log(b);
        // // console.log(c)
        // return ctAmount;
    }
    async createTx(amount, to, _fee) {
        const provider = await this.getProvider();
        const wallet = new wallet_1.Wallet(this.wallet, provider);
        const contract = await this.getContract();
        const _amount = "0x" + new bignumber_js_1.default(amount).toString(16);
        const tx = await contract.populateTransaction.transfer(to, _amount);
        // Needed *specifically* for ERC20
        tx.gasPrice = await provider.getGasPrice();
        tx.gasLimit = await contract.estimateGas.transfer(to, _amount);
        tx.chainId = (await provider.getNetwork()).chainId;
        if (!this.address)
            throw new Error("Address is undefined - you might be missing a wallet, or have not run Irys.ready()");
        tx.nonce = await provider.getTransactionCount(this.address);
        const signedTx = await wallet.signTransaction(tx);
        const txId = "0x" + (0, bundles_1.keccak256)(Buffer.from(signedTx.slice(2), "hex")).toString("hex");
        return { txId, tx: signedTx };
    }
    // TODO: create a nicer solution than just overrides (larger issue: some currencies aren't on redstone)
    async getGas() {
        return [new bignumber_js_1.default(await (0, base_1.getRedstonePrice)("ETH")), 1e18];
    }
}
exports.BaseERC20Token = BaseERC20Token;
exports.default = BaseERC20Token;
exports.erc20abi = [
    {
        constant: true,
        inputs: [],
        name: "name",
        outputs: [
            {
                name: "",
                type: "string",
            },
        ],
        payable: false,
        stateMutability: "view",
        type: "function",
    },
    {
        constant: false,
        inputs: [
            {
                name: "_spender",
                type: "address",
            },
            {
                name: "_value",
                type: "uint256",
            },
        ],
        name: "approve",
        outputs: [
            {
                name: "",
                type: "bool",
            },
        ],
        payable: false,
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        constant: true,
        inputs: [],
        name: "totalSupply",
        outputs: [
            {
                name: "",
                type: "uint256",
            },
        ],
        payable: false,
        stateMutability: "view",
        type: "function",
    },
    {
        constant: false,
        inputs: [
            {
                name: "_from",
                type: "address",
            },
            {
                name: "_to",
                type: "address",
            },
            {
                name: "_value",
                type: "uint256",
            },
        ],
        name: "transferFrom",
        outputs: [
            {
                name: "",
                type: "bool",
            },
        ],
        payable: false,
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        constant: true,
        inputs: [],
        name: "decimals",
        outputs: [
            {
                name: "",
                type: "uint8",
            },
        ],
        payable: false,
        stateMutability: "view",
        type: "function",
    },
    {
        constant: true,
        inputs: [
            {
                name: "_owner",
                type: "address",
            },
        ],
        name: "balanceOf",
        outputs: [
            {
                name: "balance",
                type: "uint256",
            },
        ],
        payable: false,
        stateMutability: "view",
        type: "function",
    },
    {
        constant: true,
        inputs: [],
        name: "symbol",
        outputs: [
            {
                name: "",
                type: "string",
            },
        ],
        payable: false,
        stateMutability: "view",
        type: "function",
    },
    {
        constant: false,
        inputs: [
            {
                name: "_to",
                type: "address",
            },
            {
                name: "_value",
                type: "uint256",
            },
        ],
        name: "transfer",
        outputs: [
            {
                name: "",
                type: "bool",
            },
        ],
        payable: false,
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        constant: true,
        inputs: [
            {
                name: "_owner",
                type: "address",
            },
            {
                name: "_spender",
                type: "address",
            },
        ],
        name: "allowance",
        outputs: [
            {
                name: "",
                type: "uint256",
            },
        ],
        payable: false,
        stateMutability: "view",
        type: "function",
    },
    {
        payable: true,
        stateMutability: "payable",
        type: "fallback",
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                name: "owner",
                type: "address",
            },
            {
                indexed: true,
                name: "spender",
                type: "address",
            },
            {
                indexed: false,
                name: "value",
                type: "uint256",
            },
        ],
        name: "Approval",
        type: "event",
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                name: "from",
                type: "address",
            },
            {
                indexed: true,
                name: "to",
                type: "address",
            },
            {
                indexed: false,
                name: "value",
                type: "uint256",
            },
        ],
        name: "Transfer",
        type: "event",
    },
];
//# sourceMappingURL=erc20.js.map